import{applyParamsToScript as L,Constr as K,Data as A,getAddressDetails as E,mintingPolicyToId as k,toUnit as R,validatorToAddress as U,fromText as M}from"@lucid-evolution/lucid";import{Effect as x}from"effect";var Ie=(e,t)=>x.gen(function*(){let n=yield*x.promise(()=>e.wallet().address()),{farmerId:r,farmId:s,aeId:a,farmArea:i,farmBorders:c,sustainabilityIndex:l,additionalData:u}=t,O=[r,s,a,BigInt(i),c,BigInt(l),u],y=A.to(O),d=yield*x.promise(()=>e.wallet().signMessage(n,y));return{data:t,signedOracleMessage:d}}),Te=(e,t)=>x.gen(function*(){let n=e.config().network,r=yield*x.promise(()=>e.wallet().address()),{paymentCredential:s}=E(r);if(!s)throw new Error("Payment credential is undefined");let a=new K(0,[String(t.initSyngentaOracleUTxO.txHash),BigInt(t.initSyngentaOracleUTxO.outputIndex)]),i=L(t.scripts.syngentaOracleMinting,[s.hash]),c={type:"PlutusV3",script:i},l=k(c),u={type:"PlutusV3",script:i},O=U(n,u),{farmerId:y,farmId:d,aeId:p,farmArea:f,farmBorders:g,sustainabilityIndex:S,additionalData:T}=t.syngentaOracleData,C=[y,d,p,BigInt(f),g,BigInt(S),T],D={syngentaOracleMinting:c,syngentaOracleSpending:u},w=A.to(C),P=R(l,M(d)),j={[P]:1n};return{tx:yield*e.newTx().collectFrom([t.initSyngentaOracleUTxO]).pay.ToContract(O,{kind:"inline",value:w},{[P]:1n}).mintAssets(j,A.void()).attach.MintingPolicy(c).addSignerKey(s.hash).completeProgram(),syngentaOraclePolicyId:l,scripts:D}}),Ce=(e,t)=>x.gen(function*(){let n=e.config().network,r=yield*x.promise(()=>e.wallet().address()),{paymentCredential:s}=E(r);if(!s)throw new Error("Payment credential is undefined");let a=k(t.scripts.syngentaOracleMinting),i=R(a,M(t.farmIdToUpdate)),c=t.scripts.syngentaOracleSpending,l=U(n,c),[u,...O]=yield*x.promise(()=>e.utxosAtWithUnit(l,i)),{farmerId:y,farmId:d,aeId:p,farmArea:f,farmBorders:g,sustainabilityIndex:S,additionalData:T}=t.newSyngentaOracleData,C=[y,d,p,BigInt(f),g,BigInt(S),T],D=A.to(C);return{tx:yield*e.newTx().collectFrom([u],A.void()).pay.ToContract(l,{kind:"inline",value:D},{[i]:1n}).addSignerKey(s.hash).attach.SpendingValidator(t.scripts.syngentaOracleSpending).completeProgram()}});import{Constr as I,Data as o}from"@lucid-evolution/lucid";var F=o.Object({txHash:o.Bytes({minLength:32,maxLength:32}),outputIndex:o.Integer()}),Me=F,h=o.Enum([o.Object({PublicKeyCredential:o.Tuple([o.Bytes()])}),o.Object({ScriptCredential:o.Tuple([o.Bytes()])})]),Ve=h,W=o.Object({paymentCredential:h,stakeCredential:o.Nullable(o.Enum([o.Object({Inline:o.Tuple([h])}),o.Object({Pointer:o.Tuple([o.Object({slotNumber:o.Integer(),transactionIndex:o.Integer(),certificateIndex:o.Integer()})])})]))}),ve=W,Y=o.Object({policyId:o.Bytes(),assetName:o.Bytes()}),_e=Y,z=o.Map(o.Bytes(),o.Map(o.Bytes(),o.Integer())),He=z,$=o.Tuple([o.Bytes(),o.Bytes(),h,h]),Be=$,G=o.Object({directoryNodeCS:o.Bytes({minLength:28,maxLength:28}),progLogicCred:h},{hasConstr:!1}),Ne=G,je=e=>e.type==="Key"?new I(0,[e.hash]):new I(1,[e.hash]),Le=e=>new I(1,[e]),Ke=e=>new I(0,[e]);import{fromText as q}from"@lucid-evolution/lucid";var J=36e5,Q=315576e5,Ye=2*Q,ze=24*J,$e=.05,Ge=process.env.NODE_ENV=="emulator"?0:1e5,qe="014e9d57e1623f7eeef5d0a8d4e6734a562ba32cf910244cd74e1680",Je="5e8aa3f089868eaadf188426f49db6566624844b6c5d529b38f3b8a7",Qe={policyId:"",assetName:""},Xe={spendSyngentaOracle:"PSpendSyngentaOracle",mintSyngentaOracle:"PMintSyngentaOracle"},Ze=q("SyngentaOracle");import{validatorToAddress as V}from"@lucid-evolution/lucid";var ct=(e,t)=>{let n={type:"PlutusV3",script:t.minting},r=e.config().network,s=V(r,n),a={type:"PlutusV3",script:t.spending},i=V(r,a);return{spendValidator:a,spendValAddress:i,mintValidator:n,mintValAddress:s}};import{addAssets as X,applyDoubleCborEncoding as Z,Constr as m,credentialToAddress as ee,Data as B,Emulator as te,generateSeedPhrase as ne,getAddressDetails as N,keyHashToCredential as b,Lucid as re,scriptHashToCredential as v,validatorToAddress as _}from"@lucid-evolution/lucid";function ht(e){return{type:"ok",data:e}}var se=async(e,t,n)=>{let r=e.config().network,s={type:"PlutusV3",script:t},a=n?_(r,s,b(n)):_(r,s);return e.utxosAt(a)},ae=(e,t)=>{if(e)try{return{type:"right",value:B.from(e,t)}}catch(n){return{type:"left",value:`invalid datum : ${n}`}}else return{type:"left",value:"missing datum"}},At=async(e,t,n,r)=>{try{return(await se(e,t,r)).flatMap(a=>{let i=ae(a.datum,n);return i.type=="right"?{outRef:{txHash:a.txHash,outputIndex:a.outputIndex},datum:i.value,assets:a.assets}:[]})}catch{return[]}},It=e=>Z(e),Tt=async e=>{let t=ne(),n=await re(new te([]),"Custom");n.selectWallet.fromSeed(t);let r=n.wallet().address;return{seedPhrase:t,address:r,assets:e}};function Ct(e){let{paymentCredential:t,stakeCredential:n}=N(e);if(!t)throw new Error("Not a valid payment address.");return{paymentCredential:t?.type==="Key"?{PublicKeyCredential:[t.hash]}:{ScriptCredential:[t.hash]},stakeCredential:n?{Inline:[n.type==="Key"?{PublicKeyCredential:[n.hash]}:{ScriptCredential:[n.hash]}]}:null}}function Dt(e,t){let n=(()=>"PublicKeyCredential"in e.paymentCredential?b(e.paymentCredential.PublicKeyCredential[0]):v(e.paymentCredential.ScriptCredential[0]))(),r=(()=>{if(e.stakeCredential&&"Inline"in e.stakeCredential)return"PublicKeyCredential"in e.stakeCredential.Inline[0]?b(e.stakeCredential.Inline[0].PublicKeyCredential[0]):v(e.stakeCredential.Inline[0].ScriptCredential[0])})();return ee(t,n,r)}var bt=e=>{let t=N(e);if(!t.paymentCredential)return{type:"error",error:new Error("undefined paymentCredential")};let n=t.paymentCredential.type=="Key"?new m(0,[t.paymentCredential.hash]):new m(1,[t.paymentCredential.hash]);if(!t.stakeCredential)return{type:"ok",data:new m(0,[n,new m(1,[])])};let r=new m(0,[new m(0,[new m(0,[t.stakeCredential.hash])])]);return{type:"ok",data:new m(0,[n,r])}},wt=(e,t)=>{let n=Math.ceil(e.length/t);return[...Array(n)].map((r,s)=>e.slice(s*t,(s+1)*t))},Pt=(e,t)=>typeof t=="bigint"?t.toString():t,Et=(e,t)=>1n+(e-1n)/t;function kt(e,t){let n=Object.entries(t),r={...e};return n.forEach(([s,a])=>{r[s]?r[s]+=a:r[s]=a}),r}function Rt(e){let t=new Map;e.lovelace&&t.set("",new Map([["",e.lovelace]]));let n=Object.keys(e);return Array.from(new Set(n.filter(s=>s!=="lovelace").map(s=>s.slice(0,56)))).sort().forEach(s=>{let a=n.filter(c=>c.slice(0,56)===s),i=new Map;a.sort().forEach(c=>{i.set(c.slice(56),e[c])}),t.set(s,i)}),t}function Ut(e){let t={lovelace:e.get("")?.get("")||BigInt(0)};for(let[n,r]of e)if(n!=="")for(let[s,a]of r)t[n+s]=a;return t}function Mt(e,t){let n=[],r=!1,s=new Map(Object.entries(t));for(let a of e)if(!a.scriptRef){r=!1;for(let[i,c]of s)if(Object.hasOwn(a.assets,i)){let l=a.assets[i];l>=c?s.delete(i):s.set(i,c-l),r=!0}if(r&&n.push(a),s.size==0)break}return s.size>0?{type:"error",error:new Error("Insufficient funds")}:{type:"ok",data:n}}function Vt(e,t){let n=e.concat(t),r=oe(n),s=new Map;return r.forEach((a,i)=>{s.set(a.txHash+a.outputIndex,BigInt(i))}),e.flatMap(a=>{let i=s.get(a.txHash+a.outputIndex);return i!==void 0?i:[]})}function oe(e){return e.sort((t,n)=>t.txHash<n.txHash?-1:t.txHash>n.txHash?1:t.txHash==n.txHash?t.outputIndex<n.outputIndex?-1:1:0)}function vt(e){return e.map(t=>t.assets).reduce((t,n)=>X(t,n),{})}function _t(e,t){return Object.fromEntries(Object.entries(e).filter(([n])=>n.startsWith(t)))}function Ht(e,t){return Object.fromEntries(Object.entries(e).filter(([n])=>t.includes(n.slice(0,56))))}function Bt(e,t){for(let[n,r]of Object.entries(t))Object.hasOwn(e,n)&&(e[n]<r?delete e[n]:e[n]>r?e[n]-=r:delete e[n]);return e}var Nt=async(e,t)=>(await fetch(`/api/blockfrost/1/assets/${e}`,{headers:{project_id:t}}).then(r=>r.json())).onchain_metadata,jt=async(e,t,n)=>(await e.utxosAt(t)).filter(s=>{let a=Object.keys(s.assets);return Array.from(new Set(a.filter(c=>c!=="lovelace").map(c=>c.slice(0,56)))).includes(n)}),H=e=>e.sort((t,n)=>t.txHash>n.txHash?1:t.txHash<n.txHash?-1:t.outputIndex>n.outputIndex?1:-1),Lt=e=>{let t=e.concat(e.concat(e)).map(n=>new m(0,[n]));return console.log("Freeze Redeemer: ",t),B.to(t)},Kt=({referenceInputs:e,inputs:t,outputs:n,inputSelectionCriteria:r,refInputSelectionCriteria:s,outputSelectionCriteria:a,makeRedeemer:i})=>{let l=H(e).map(d=>[d,BigInt(e.findIndex(p=>d==p))]),u;if(r&&t){let p=H(t).map(g=>[g,BigInt(t.findIndex(S=>g==S))]),f=[];for(let[g,S]of p)r(g)&&f.push(BigInt(S));u=f.length>0?f:void 0}let O;if(a&&n){let d=[];for(let[p,f]of n.entries())a(f)&&d.push(BigInt(p));O=d.length>0?d:void 0}let y=[];for(let[d,p]of l)s(d)&&y.push(BigInt(p));return i(y,u,O)};export*from"@lucid-evolution/lucid";export{Qe as ADA,ve as AddressD,W as AddressSchema,_e as AssetClassD,Y as AssetClassSchema,Ve as CredentialD,h as CredentialSchema,Be as DirectoryNodeDatum,$ as DirectoryNodeDatumSchema,J as ONE_HOUR_MS,Q as ONE_YEAR_MS,Me as OutputReference,F as OutputReferenceSchema,$e as PROTOCOL_FEE,qe as PROTOCOL_PAYMENT_KEY,Je as PROTOCOL_STAKE_KEY,Ne as ProtocolParametersDatum,G as ProtocolParametersDatumSchema,Xe as REF_SCRIPT_TOKEN_NAMES,Ze as SYNGENTA_ORACLE_TOKEN_NAME,Ge as TIME_TOLERANCE_MS,ze as TWENTY_FOUR_HOURS_MS,Ye as TWO_YEARS_MS,He as Value,z as ValueSchema,wt as chunkArray,Te as deploySyngentaOracle,Et as divCeil,Ht as filterForeignPoliciesFromAssets,_t as filterPolicyFromAssets,Ct as fromAddress,bt as fromAddressToData,Rt as fromAssets,Tt as generateAccountSeedPhrase,Vt as getInputUtxoIndices,ct as getMultiValidator,Ie as getSignedOracleMessage,Ke as keyHashToCredentialData,Lt as makeFreezeRedeemer,Kt as makeTransferRedeemer,Nt as mintingMetadataFromAsset,ht as ok,ae as parseSafeDatum,At as parseUTxOsAtScript,Bt as removeAssets,Pt as replacer,Le as scriptHashToCredentialData,Mt as selectUtxos,oe as sortByOutRefWithIndex,H as sortUtxosByOutRef,vt as sumUtxoAssets,Dt as toAddress,Ut as toAssets,It as toCBORHex,je as toCredentialData,kt as union,Ce as updateSyngentaOracle,jt as utxosAtAddressWithPolicyId,se as utxosAtScript};
